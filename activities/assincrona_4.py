# -*- coding: utf-8 -*-
"""Assincrona 4

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1m1kILMmZnXZXbF7kK5OciTc88a0igecC
"""

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from scipy.optimize import fmin

#@title Questão 1 - Gerando os Dados
np.random.seed(12803112)
n_rep = 10000

s0 = 2
x0 = 10

N_arr = np.array([2, 3, 4, 5, 10, 50, 100])

s = np.zeros((len(N_arr), n_rep))
V = np.zeros((len(N_arr), n_rep))

for i in range(n_rep):
  count = 0
  for j in N_arr:
    aux = x0 + s0*np.random.randn(j)

    s[count][i] = (np.std(aux, ddof = 1))
    V[count][i] = ((np.std(aux, ddof = 1))**2)

    count += 1

#@title Questão 1- Histogramas
for i in range(7):

  fig, ax = plt.subplots(1, 2, figsize = (15, 10))

  ax[0].hist(s[i], bins = 45)
  ax[0].set_title(f'Histograma do Desvio-Padrão (N={N_arr[i]})')
  ax[0].set_xlabel('Valores do desvio-padrão', fontsize=14)
  ax[0].set_ylabel('Frequência', fontsize=14)
  ax[0].set_ylim(0,1600)
  ax[0].axvline(2,color ='r', label = '$\sigma_0 = 2$')
  ax[0].legend()

  ax[1].hist(V[i], bins = 45)
  ax[1].set_title(f'Histograma da Variância (N={N_arr[i]})')
  ax[1].set_xlabel('Valores do desvio-padrão', fontsize=14)
  ax[1].set_ylabel('Frequência', fontsize=14)
  ax[1].axvline(4, color ='r', label = '$V_0 = 4$')
  ax[1].set_ylim(0,7100)
  ax[1].legend()

#@title Questão 1 - sm e Vm
np.random.seed(12803112)
sm = np.zeros(len(N_arr))
s_sm = np.zeros(len(N_arr))

Vm = np.zeros(len(N_arr))
s_Vm = np.zeros(len(N_arr))

for i in range(len(N_arr)):
  sm[i] = np.mean(s[i])
  s_sm[i] = np.std(s[i], ddof = 1)

  Vm[i] = np.mean(V[i])
  s_Vm[i] = np.std(V[i], ddof = 1)

  print(f'sm{N_arr[i]} = {sm[i]:.3f} ± {s_sm[i]/np.sqrt(n_rep):.3f}')
  print(f'Vm = {Vm[i]:.3f} ± {s_Vm[i]/np.sqrt(n_rep):.3f}\n')

#@title Questão 1 - contadores
contador1 = np.zeros(len(N_arr))
contador2 = np.zeros(len(N_arr))

for i in range(len(N_arr)):
  for j in range(n_rep):
    if s[i][j] < s0:
      contador1[i] += 1
    if V[i][j] < s0**2:
      contador2[i] += 1

f1 = contador1/n_rep
f2 = contador2/n_rep

s_n1 = np.sqrt(n_rep*f1*(1-f1))
s_n2 = np.sqrt(n_rep*f2*(1-f2))

print(f'casos de s <= s0 \n{contador1}')
print(f'\nincerteza dos casos \n{s_n1}')

print(f'\ncasos de v <= v0 \n{contador2}')
print(f'\nincerteza dos casos \n{s_n2}')

#@title Questão 2 - Gerando dados
#DADOS = np.loadtxt('dados_Augustiner.txt')
DADOS = np.loadtxt('dados_Budweiser.txt')
#DADOS = np.loadtxt('dados_Erdinger.txt')
t = DADOS[:,0].copy()
h = DADOS[:,1].copy()
sh = DADOS[:,2].copy()

#@title Questão 2- MMQ
g = np.zeros((2, len(t)))
M = np.zeros((2, 2))
D = np.zeros(2)

g[0] = 1
g[1] = t

y = np.log(h)
sy = sh/h

for i in range(2):
  D[i] = sum(y*g[i]/(sy**2)) 
  for j in range(2):
    M[i][j] = sum(g[i]*g[j]/(sy**2))

V = np.linalg.inv(M)
A = np.dot(V, D)

print(f'a1 = {A[0]} ±  {np.sqrt(V[0][0])}')
print(f'a2 = {A[1]} ±  {np.sqrt(V[1][1])}')
print(f'\nCovariancia = {V[0][1]}')
print(V)


h0 = np.exp(A[0])
sh0 = np.exp(A[0])*np.sqrt(V[0][0])

tau = -1/A[1]
stau = (1/(A[1]**2))*np.sqrt(V[1][1])

print(f'\nh0 = {h0:.5f} ± {sh0:.5f}')
print(f'tau = {tau:.4f} ± {stau:.4f}')

h_aj = h0*np.exp(-t/tau)

chi2 = sum(((h-h_aj)/sh)**2)
NGL = len(t)-2

print(f'\nchi²= {chi2:.2f}')
print(f'NGL = {NGL}')

fig, ax = plt.subplots(2, 1);

ax[0].plot(t, h_aj, label = '$h_{ajust}$');
ax[0].set_title('Ajuste e dados da Budweiser')
ax[0].set_ylabel('h(t) $(cm)$');
ax[0].scatter(t, h, label = 'h', color='orange', s=15);
ax[0].errorbar(t,h,sh,fmt='.');
ax[0].legend();
ax[1].set_xlabel('Tempo (s)');
ax[1].axhline(0);
ax[1].set_ylabel('Resíduos $(cm)$');
ax[1].errorbar(t,h-h_aj,sh,fmt='.');

#@title Questão 2 - fmin
f_h = lambda A: A[0]*np.exp(-t/A[1])
f_Q = lambda A: np.sum( ((h - f_h(A))/sh)**2 )
Ac = [ max(h), 150 ]
A1 = fmin ( f_Q, Ac )

print(f'\nMatriz dos parametros = {A1}')

h_aj1 = A1[0]*np.exp(-t/A1[1])
fig, ax = plt.subplots(2, 1);
ax[0].plot(t, h_aj1, label = '$h_{ajust}$');
ax[0].set_ylabel('h(t) $(cm)$');
ax[0].scatter(t, h, label = 'h', color='orange', s=15);
ax[0].errorbar(t,h,sh,fmt='.');
ax[0].set_title('Ajuste por meio da busca numérica de mínimos')
ax[0].legend();
ax[1].set_xlabel('Tempo (s)');
ax[1].set_ylabel('Resíduos $(cm)$');
ax[1].axhline(0);
ax[1].errorbar(t,h-h_aj1,sh,fmt='.');


chi2 = sum(((h-h_aj1)/sh)**2)
print(f'\nchi² = {chi2:.2f}')

#@title Incertezas por Expansão em Taylor
tau_c = -1/A[1]
h0_c = np.exp(A[0])

g_ = np.zeros((2, len(t)))
M_ = np.zeros((2, 2))

g_[0] = np.exp(t/tau_c)
g_[1] = (h0_c*t/(tau_c**2))*np.exp(-t/tau_c)

for i in range(2):
  for j in range(2):
    M_[i][j] = sum(g_[i]*g_[j])/(sh0**2)

V_ = np.linalg.inv(M_)

print(f'sh0_fmin = {np.sqrt(V_[0][0]):.5f}')
print()
print(f'stau_fmin = {np.sqrt(V_[1][1]):.4f}\n')

print(f'matriz de cov \n{V_}')

print(sh0**2)